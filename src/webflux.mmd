Mind Map generated by NB MindMap plugin   
> __version__=`1.1`,showJumps=`true`
---

# WebFlux知识结构

## Spring WebFlux

### Reactive Core\(响应式核心\)
> collapsed=`true`


#### HttpHandler
> collapsed=`true`

- NOTE
<pre>一个对于HTTP请求的略偏底层的协定；
规范了Tomcat, Jetty, Netty, Undertow, Servlet3.1等服务器。
旨在对于不同的Web服务器提供更加抽象统一的接口。</pre>

##### Netty

##### Undertow

##### Tomcat

##### Jetty

##### Servlet3\.1

#### WebHandler API
> align=`center`,collapsed=`true`

- NOTE
<pre>基于HttpHandler，并提供稍微高级一些，且更加常用的Web通用API，使代码编写更加容易；
并构建更加具体的编程模型。
由多个部分组成&quot;责任链式&quot;的处理模式(和Netty的链式处理思想一样)。</pre>

##### Special Bean Types\(特殊的Bean类型\)
> collapsed=`true`


###### WebExceptionHandler
- NOTE
<pre>提供对于Filter链中各个Filter异常以及WebHandler异常的处理，数量0-N。</pre>

###### WebFilter
- NOTE
<pre>提供&quot;拦截式&quot;逻辑处理, 数量0-N。
在过滤链其余部分的前面或后面以及WebHandler的前面或后面进行拦截(就是Filter的意思)。</pre>

###### WebHandler
- NOTE
<pre>处理器，也是主要的业务处理部分(Spring MVC中的Controller)。</pre>

###### WebSessionManager
- NOTE
<pre>对于WebSession的一个管理器。</pre>

###### ServerCodecConfigurer
- NOTE
<pre>用于访问HttpMessageReader实例以解析表单数据和文件数据；
然后经由ServerWebExchange的方法把数据传递出去。</pre>

###### LocaleContextResolver
- NOTE
<pre>LocaleContext的解析器。</pre>

###### ForwardedHeaderTransformer
- NOTE
<pre>处理HTTP头部，包括提取和移除某些头部键值对，或者只移除。</pre>

##### Form Data
- NOTE
<pre>ServerWebExchange提供Mono&lt;MultiValueMap&lt;String, String&gt;&gt; getFormData()方法；
此方法用于访问表单数据。</pre>

##### Multipart Data
- NOTE
<pre>ServerWebExchange提供了Mono&lt;MultiValueMap&lt;String, Part&gt;&gt; getMultipartData()方法；
此方法用来访问Multipart数据。

DefaultServerWebExchange使用配置好的HttpMessageReader&lt;MultiValueMap&lt;String, Part&gt;&gt;把&quot;multipart/form-data&quot;的内容解析到MultiValueMap里去。

当下，Synchronoss NIO Multipart是唯一被支持的可以进行对multipart请求进行非阻塞解析的第三方库。

为了把multipart数据解析成流的形式，可以使用Flux&lt;part&gt;作为HttpMessageReader&lt;Part&gt;的返回值以替换HttpMessageReader&lt;MultiValueMap&lt;String, Part&gt;&gt;。

例如，在一个注解Controller里面，使用@RequestPart意味着根据名字对于每个独立部分进行Map形式的访问时需要对整个multipart数据进行解析。

作为对比，可以使用@RequestBody把请求体解析进Flux&lt;Part&gt;而不必整合进MultiValueMap。</pre>

##### Forwarded Headers
- NOTE
<pre>如果请求经过代理服务器(比如Nginx)，请求的主机地址，端口，和请求方式可能会被更改；
此时对于客户端来说，正确地找到主机地址等信息会是一个挑战。

ForwardedHeaderTransformer是一个组件类，提供基于请求头修改host，port，和方法的功能；
然后移除这些请求头，此类可以被声明成bean形式。

可以通过设置ForwardedHeaderTransformer的removeOnly=true来实现只移除而不访问某些不安全头部的效果。
</pre>

#### Filters\(过滤器\)
> collapsed=`true`

- NOTE
<pre>在WebHandler API里面，你可以使用WebFilter去实现'拦截式'逻辑；
一个WebFilter可以拦截进入其他的WebFilter或者WebHandler或从其产生的数据流。

当使用WebFlux Config时，你会发现注册一个WebFilter就像把它声明为Spring Bean那样容易；
可选的，可以使用@Order注解或实现Ordered接口实现对WebFilter排序。</pre>

##### CORS\(跨域访问\)
- NOTE
<pre>Spring WebFlux通过控制器组件的注解对于CORS提供一个细粒度的支持。
然而，当你使用Spring Security时，我们推荐(不是我，是Spring官方)使用内置的CorsFilter类，
此类必须放在Spring Security的所有Filter的前面。</pre>

#### Exceptions\(异常\)
- NOTE
<pre>在WebHandler API里面，你可以使用WebExceptionHandler去处理来自WebFilter或WebHandler的异常。

当使用WebFlux Config时，注册一个WebExceptionHandler就像声明一个Spring Bean那样容易。

同样以可以使用@Order或实现Ordered接口实现设置前后顺序。

有两个可用的WebExceptionHandler实现，分别为：
ResponseStatusExceptionHandler: 通过设置response的HTTP Code 来处理ResponseStatusExceptionHandler类型的异常。
WebFluxResponseStatusExceptionHandler: ResponseStatusExceptionHandler的继承类, 可以在任何异常里面决定@ResponseStatus注解的HTTP状态码。</pre>

#### Codecs\(编/解码器\)
> collapsed=`true`

- NOTE
<pre>spring-web和spring-core模块提供了对，通过拥有背压反应式流的非阻塞IO，从byte数据到高级对象的反序列化和高级对象到byte的序列化的支持。

如下描述了以上的支持：

Encoder和Decoder是底层协议，用于编/解码分离开的HTTP内容。

HttpMessageReader和HttpMessageWriter是用于编/解码HTTP 消息内容的编/解码器。

一个编码器可以被EncoderHttpMessageWriter封装使其可以合适的用于Web应用；
同样，解码器也可以被DecoderHttpMessageReader封装。

DataBuffer抽象并封装了不同服务器的byte buffer(诸如Netty的ByteBuf, java.nio.ByteBuffer)；
这也是所有的编/解码器工作的数据依赖(或数据来源)。

spring-core模块提供了byte[]，ByteBuffer，DataBuffer，Resource，和String的编码器以及解码器实现。

对于表单数据，二进制/文件内容，服务器发送的事件等；
spring-web模块提供了包括Jackson JSON，Jackson Smile，JAXB2，Protocol Buffers的编/解码器以及只支持web的HTTP消息读/写器实现。

ClientCodecConfigurer和ServerCodecConfigurer通常用于配置和自定义Web应用程序里面的编/解码器。</pre>

##### Jackson JSON\(杰克逊JSON\)
- NOTE
<pre>Jackson2Decoder工作原理:
1. Jackson是异步非阻塞的解析器, 用于把字节块流聚合到TokenBuffer的每个块中, 其中, 每一块代表一个JSON对象
2. 每一个TokenBuffer都会传递到Jackson的ObjectMapper以创建一个更高等级的对象
3. 当解码一个单值publisher(例如Mono), 就会产生一个TokenBuffer
4. 当解码一个多值publisher(例如Flux), 一旦一个完整的对象接收到足够的byte, 每一个TokenBuffer都会被传递到ObjectMapper, 输入的对象可以是JSON数组, 如果Content-Type是&quot;application/stream+json&quot;的话, 那么也可以是按行分割的JSON

Jackson2Decoder目的: 将字节流解码为JSON并使用Jackson 2.9转换为Object的. 

Jackson2Encoder工作原理:
1. 对于单值publisher, 简单地通过ObjectMapper进行序列化就行
2. 对于用&quot;application/json&quot;修饰的多值publisher, 默认情况下使用Flux.collectToList()把值集合起来然后系列化这个集合
3. 对于流媒体类型(例如: application/stream+json, application/stream+x-jackson-smile)修饰的多值publisher,  使用基于行分隔符的JSON格式对每个值进行编码, 写出, 和刷新
4. 对于SSE, 每个事件都会调用Jackson2Encoder, 执行的结果会被主动刷新以确保传输没有任何的延迟

Jackson2Encoder和Jackson2Decoder都不支持String以及String序列的编/解码, 如果需要从Flux&lt;String&gt;得到JSON数组, 应该使用Flux.collectToList()并对Mono&lt;List&lt;String&gt;&gt;进行编码</pre>

##### Form Data\(表单数据\)
- NOTE
<pre>FormHttpMessageReader和FormHttpMessageWriter支持编/解码&quot;application/x-www-form-urlencoded&quot;类型的内容

在经常需要从多个位置访问表单数据的服务端, ServerWebExchange提供了专用的getFormData()方法通过FormHttpMessageReader来解析内容然后把结果缓存起来以供多次访问

一旦getFormData()被调用, 请求体里面的原生数据就没法被再次访问了, 介于此, 应用应通过ServerWebExchange来访问被缓存的数据而不是访问原生的数据
P.s.其实吧, 我觉得这么设计可能是因为Netty的引用计数导致的</pre>

##### Multipart\(文件数据/二进制数据\)
- NOTE
<pre>MultipartHttpMessageReader和MultipartHttpMessageWriter提供对于&quot;multipart/form-data&quot;类型的数据的编/解码支持

实际上, MultipartHttpMessageReader通过代理另一个HttpMessageReader来完成实际的数据解析(把数据解析成Flux&lt;Part&gt;), 然后只是简单地把结果集合进一个MultiValueMap里去

当下, Synchronoss NIO Multipart被用来完成实际的解析

在经常需要从多个位置访问multipart数据的服务端, ServerWebExchange提供了专用的getMultipartData()方法通过MultipartHttpMessageReader来解析内容然后把结果缓存起来以供多次访问
(类似表单数据)

一旦getMultipartData()被调用, 请求体里面的原生数据就没法再次被访问, 基于此, 应用应当一致的使用getMultipartData()来完成对于parts的多次地, map形式地访问; 或者使用SynchronossPartHttpMessageReader来进行唯一一次的对于Flux&lt;Part&gt;的访问(之后数据就被销毁了)
P.s.这么设计的原因同表单数据访问</pre>

##### Limits\(限制\)
- NOTE
<pre>把输入流的部分或全部数据整到缓冲区的Decoder和HttpMessageReader的实现类, 可以设置一个内存所能包含的最大字节数大小, 以避免爆内存

在某些情况下会发生缓冲区处理, 比如聚合输入的数据成一个对象(HTTP请求都是一段一段发送的, 所以要聚合); 或者分割输入流时, 也会发生缓冲

配置缓冲区最大大小时, 可以检查提供的Decoder或HttpMessageReader是否已经拥有了maxInMemorySize这个属性; 在WebFlux, 提供了一个单独的地方用来为所有的编解码器设置这个属性; 在客户端里, 可以通过WebClient.Builder设置此属性

对于Multipart类型的数据来说, 此限制只作用于非文件的部分; 对于文件部分, 它将决定文件写入硬盘的阀值; 对于写入到硬盘的文件部分来说, 有一个maxDiskUsagePerPart属性来限制每部分文件的硬盘空间的数量

同样, 有一个maxParts属性限制在一次Multipart请求中的文件部分总数量, 为了在WebFlux配置这三个属性, 需要向ServerCodecConfigurer提供一个预配置的MultipartHttpMessageReader实例</pre>

##### Streaming\(流式\)
- NOTE
<pre>流式传输到HTTP响应时, 应增加心跳检测机制, 以及时地断开连接</pre>

##### DataBuffer\(数据缓冲组件\)
- NOTE
<pre>对各种服务器的字节缓冲区进行了封装

对于Netty的引用计数, WebFlux一般不关心此问题, 除非直接消费或生产数据而不是依靠编/解码器进行和高级对象的转换(就是不走编解码器, 手动解析数据, 俗称'造轮子', 有可能会造成内存泄漏), 或者自己造编/解码器(也有可能会造成内存泄漏)</pre>

#### Logging\(日志\)

### DispatcherHandler\(分发处理器\)
> collapsed=`true`

- NOTE
<pre>一个中央Handler, 也就是DispatcherHandler负责请求的转发, 实际的请求处理是被配置好的代理组件, 这种工作模式是灵活的, 且支持各种各样的工作流

DispatcherHandler通过Spring配置自动发现它需要的代理组件它也被设计成一个Spring Bean形式并通过实现ApplicationContextAware接口实现对它所在的上下文的访问

WebFlux的Spring配置通常包含:
1. Bean名字为&quot;webHandler&quot;的DispatcherHandler
2. WebFilter和WebExceptionHandler Beans
3. DispatcherHandler的特殊的Bean
4. 其他

配置通常传递给WebHttpHandlerBuilder来构建处理链

例如:

ApplicationContext context = ...
HttpHandler handler = WebHttpHandlerBuilder.applicationContext(context).build();</pre>

#### Special Bean Types\(特殊的Bean类型\)
> collapsed=`true`

- NOTE
<pre>DispatcherHandler把请求委托给特殊的Bean来完成请求处理并返回适当的回复(response)
</pre>

##### HandlerMapping
- NOTE
<pre>把一个请求映射到一个Handler上面去, 映射基于一些规范, 规范的细节由HandlerMapping的实现决定-基于注解的控制器, 简单URL模式映射, 和其他的

主要的HandlerMapping实现类是用于对@RequestMapping注解的方法的RequestMappingHandlerMapping, 对于函数端点路由的RouterFunctionMapping, 和对于URI路径模式的显式注册以及WebHandler实例的SimpleUrlHandlerMapping</pre>

##### HandlerAdapter
- NOTE
<pre>帮助DispatcherHandler对于某个请求调用已被映射的Handler而无关于此Handler实际上是怎么被调用的

例如, 调用一个带注解的控制器需要先解析注解, 而此类可以让DispatcherHandler免于此繁琐的细节处理</pre>

##### HandlerResultHandler
- NOTE
<pre>处理来自处理器调用的结果并最终确定回复响应(写出HttpResponse的意思)</pre>

#### WebFlux Config\(WebFlux配置\)
- NOTE
<pre>WebFlux Config是一个不错的配置方法</pre>

#### Processing\(处理\)
- NOTE
<pre>DispatcherHandler处理请求的工作流程:
1. 每个HandlerMapping都会被唤醒以找到匹配的处理器, 第一个匹配的将会作为此次请求的处理器
2. 一旦某个处理器被找到, 它将会被一个适当的HandlerAdapter执行, 此类会把执行结果(返回值)封装成HandlerResult
3. HandlerResult会被传递到一个合适的HandlerResultHandler来进行视图渲染或直接写入到response里面去来完成此次执行</pre>

#### Result Handling\(结果处理\)
> collapsed=`true`

- NOTE
<pre>Handler调用结果会通过HandlerAdapter, 然后封装成一个HandlerResult, 并附加一些文本信息, 然后传递到第一个可以处理它的HandlerResultHandler来进行最终处理

以下是HandlerResultHandler的一些默认实现:
ResponseEntityResultHandler
ServerResponseResultHandler
ResponseBodyResultHandler
ViewResolutionResultHandler</pre>

##### ResponseEntityResultHandler
- NOTE
<pre>ResponseEntity, 通常来自@Controller实例。</pre>

##### ServerResponseResultHandler
- NOTE
<pre>ServerResponse, 通常来自功能端点</pre>

##### ResponseBodyResultHandler
- NOTE
<pre>来自@ResponseBody方法或@RestController类的返回值</pre>

##### ViewResolutionResultHandler
- NOTE
<pre>CharSequence, View, Model, Map, Rendering或任何其他Object都会被视为模型属性</pre>

#### Exceptions\(异常\)
- NOTE
<pre>处理器调用失败或通过HandlerResultHandler处理处理器返回值时失败都会触发特定的错误函数

只要发生错误, 错误函数就能更改响应状态

可以在选取一个处理器处理异常之前使用@ControllerAdvice处理异常</pre>

#### View Resolution\(视图解析\)

### Annotated Controllers\(注解控制器\)

#### @Controller
- NOTE
<pre>即可以通过标准的SpringBean方法定义一个控制器Bean, 也可以通过@Controller注解构建

@Controller注解提供自动推断和路径扫描的方法来装配控制器组件, 可以让控制器类被识别成Web组件

@RestController是@Controller和@ResponseBody的组合注解, 意味着返回值直接写入到response body而不是进行视图渲染或写入HTML模板</pre>

#### Request Mapping\(请求映射\)
> collapsed=`true`

- NOTE
<pre>@RequestMapping注解常用来给控制器方法提供映射关系; 它拥有多种属性,来进行匹配, 比如通过URL匹配, 通过HTTP 请求方法匹配, 请求参数, 头部, 或媒体类型进行匹配

既可以在类层面使用此注解以表明对类的所有方法都囊括此路径映射, 也可以在方法层面使用来进行特定的请求处理

@RequestMapping有一些子注解, 来进行请求方式的限定:
@GetMapping
@PostMapping
@PutMapping
@DeleteMapping
@PatchMapping</pre>

##### URI Patterns\(URI匹配\)
- NOTE
<pre>URI映射的通配符的使用
?: 匹配一个字符
*: 在一个路径片段里面匹配0或多个字符
**: 匹配0或多个路径片段

同样, 你也可以通过在路径里面设置变量来获取URI里面的值
例如:
@GetMapping(&quot;/owners/{ownerId}/pets/{petId}&quot;)
public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
    // ...
}
路径变量参数同样可用于类级别的映射

URI变量可以自动转换成合适的类型, 否则会抛出TypeMismatchException异常, 简单基本类型(诸如: int, double, long, String, Date等)都可以被直接获取

URI变量也可以被显式地命名(比如: @PathVariable(&quot;customId&quot;) )

语法{*varName}表示匹配0或多个余下的路径片段, 比如(&quot;/resources/{*path}&quot;)

语法{varName:正则表达式}可以使用正则表达式的方式完成匹配

URI还可以使用嵌入式的占位符${...}, 以在系统启动时通过属性的方式注入

WebFlux的URI不同于SpringMVC的一点就是, 不能使用后缀表达式</pre>

##### Pattern Comparison\(模式比较\)
- NOTE
<pre>当多个映射匹配一个URL时, 必须比较它们以发现最佳的匹配项; 这项工作由PathPattern.SPECIFICITY_COMPARATOR完成, 它负责寻找最佳匹配项

对于每个可匹配项, 会根据URI变量和占位符的数量计算得到一个值, URI变量的值比占位符小, 分数小的匹配, 若分数相同, 长的匹配</pre>

##### Consumable Media Types\(可消费的媒体类型\)
- NOTE
<pre>可以通过请求的Content-Type属性来细粒化请求匹配, 例如:
@PostMapping(path = &quot;/pets&quot;, consumes = &quot;application/json&quot;)
public void addPet(@RequestBody Pet pet) {
    // ...
}

consumes属性同样支持否定形式, 例如: !text/plain意味着匹配所有非text/plain的请求

对于类层次的consumes属性, 当方法体使用了consumes属性时, 意味着会重写类的consumes属性

MediaType封装了一些类型</pre>

##### Producible Media Types\(可产生的媒体类型\)
- NOTE
<pre>可以根据请求的Accept属性细粒化请求映射, 比如:
@GetMapping(path = &quot;/pets/{petId}&quot;, produces = &quot;application/json&quot;)
@ResponseBody
public Pet getPet(@PathVariable String petId) {
    // ...
}
表示除了匹配URI之外, 还要匹配接受的返回类型为&quot;application/json&quot;的那个请求

媒体类型还能指定字符集, 同时也支持取反操作, (匹配只接受除了此类型之外的请求)

方法级别的同样可以覆写类级别的设置</pre>

##### Parameters and Headers\(参数和请求头\)
- NOTE
<pre>可以根据请求参数细粒化匹配:
1.根据某个参数是否存在进行匹配
2.根据某个参数是否不存在进行匹配
3.根据某个参数是否等于某个确定的值进行匹配
例如:
@GetMapping(path = &quot;/pets/{petId}&quot;, params = &quot;myParam=myValue&quot;) 
public void findPet(@PathVariable String petId) {
    // ...
}
检查myParam是否等于myValue

同样的方法可以检测是否请求头匹配
例如:
@GetMapping(path = &quot;/pets&quot;, headers = &quot;myHeader=myValue&quot;) 
public void findPet(@PathVariable String petId) {
    // ...
}</pre>

##### HTTP HEAD, OPTIONS

##### Custom Annotations\(自定义注解\)
- NOTE
<pre>Spring允许组合注解来实现请求映射。
旨在得到@RequestMapping的一个更加细粒化的子注解。

如果想获得更加细粒化的逻辑匹配。
继承RequestMappingHandlerMapping并覆写getCustomMethodCondition()方法。
这样可以检查自定义属性和返回你自己的请求条件(RequestCondition)</pre>

##### Explicit Registrations\(显式地注册\)
- NOTE
<pre>你可以程序化的注册处理器方法，这可以适用于动态注册或高级情形。
比如同一个处理器在不同URL下的不同实例。

举例：
@Configuration
public class MyConfig {

    @Autowired
    public void setHandlerMapping(RequestMappingHandlerMapping mapping, UserHandler handler)
            throws NoSuchMethodException { // 为控制器注入目标处理器和处理器映射

        RequestMappingInfo info = RequestMappingInfo
                .paths(&quot;/user/{id}&quot;).methods(RequestMethod.GET).build(); // 准备请求映射元数据

        Method method = UserHandler.class.getMethod(&quot;getUser&quot;, Long.class); // 获取处理器方法

        mapping.registerMapping(info, handler, method); // 添加注册 
    }

}</pre>

#### Handler Methods\(处理器方法\)
- NOTE
<pre>@RequestMapping拥有灵活的处理器方法签名；
可以从一系列已支持的方法参数和返回值里面选取合适的作为使用。</pre>

##### Method Arguments\(方法参数\)
> collapsed=`true`

- NOTE
<pre>在那些需要处理阻塞IO的参数上可以支持响应式类型(比如：Reactor，RxJava或其他的)。
不需要阻塞的参数不建议使用响应式类型

JDK8的Optional和带有required属性的注解搭配使用，等同于注解添上required=false</pre>

###### ServerWebExchange
- NOTE
<pre>完全访问ServerWebExchange。
ServerWebExchange是一个容器，包含了：
HTTP Request和HTTP Response；
request和session属性；
checkNotModified方法和其他</pre>

###### ServerHttpRequest, ServerHttpResponse
- NOTE
<pre>添加HTTP request和response</pre>

###### WebSession
- NOTE
<pre>访问Session；
除非添加属性，否则不会强制开始一个新的session;
支持响应式类型。</pre>

###### java\.security\.Principal
- NOTE
<pre>当前经过身份验证的用户-可能是特定的Principal实现类（如果已知）。
支持响应式类型。</pre>

###### org\.springframework\.http\.HttpMethod
- NOTE
<pre>请求的方法</pre>

###### java\.util\.Locale
- NOTE
<pre>当前的请求区域设置，由最具体的可用LocaleResolver确定;
实际上是配置的LocaleResolver/LocaleContextResolver。</pre>

###### java\.util\.TimeZone \+ java\.time\.ZoneId
- NOTE
<pre>与当前请求关联的时区，由LocaleContextResolver确定。</pre>

###### @PathVariable
- NOTE
<pre>用来访问URI模板变量</pre>

###### @MatrixVariable
- NOTE
<pre>用来访问URI路径片段里面的键值对</pre>

###### @RequestParam
- NOTE
<pre>用来访问Servlet请求参数；
参数的值已被转换成已声明的方法的参数类型。

注意：@RequestParam的使用是可选的</pre>

###### @RequestHeader
- NOTE
<pre>用来访问请求头；
请求头的值已经被转换成已声明的方法的参数类型。</pre>

###### @CookieValue
- NOTE
<pre>用来访问Cookie；
Cookie的值已经被转换成已声明的方法的参数类型。</pre>

###### @RequestBody
- NOTE
<pre>用来访问HTTP请求体；
通过HttpMessageReader实例，请求体内容已经被转换成已声明的方法的参数类型。
支持响应式类型。</pre>

###### HttpEntity\<B\>
- NOTE
<pre>访问请求的头部和请求体；
请求体被HttpMessageReader实例转换成已声明的方法的参数类型。
支持响应式类型。</pre>

###### @RequestPart
- NOTE
<pre>用来访问&quot;multipart/form-data&quot;类型的请求的某个part。
支持响应式类型。</pre>

###### java\.util\.Map, org\.springframework\.ui\.Model, and org\.springframework\.ui\.ModelMap\.
- NOTE
<pre>用于访问HTML控制器中使用的模型，并作为视图渲染的一部分呈现给模板。</pre>

###### @ModelAttribute
- NOTE
<pre>用于访问应用了数据绑定和验证的模型中的现有属性（如果不存在，则进行实例化）。

@ModelAttribute的使用是可选的。</pre>

###### Errors, BindingResult
- NOTE
<pre>用于访问命令对象的验证和数据绑定中的错误。

必须在经过验证的方法参数后立即声明Errors或BindingResult参数。</pre>

###### SessionStatus \+ class\-level @SessionAttributes
- NOTE
<pre>用于标记表单处理完成；
将触发清除所有通过类级别@SessionAttributes注解声明的Session属性。</pre>

###### UriComponentsBuilder
- NOTE
<pre>用于准备相对于当前请求的Host，Port，Scheme和Path的URL。</pre>

###### @SessionAttribute
- NOTE
<pre>用于访问任何Session属性</pre>

###### @RequestAttribute
- NOTE
<pre>用于访问请求属性。</pre>

###### Any other argument
- LINK
<pre>https://docs.spring.io/spring-framework/docs/5.2.5.BUILD-SNAPSHOT/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-</pre>
- NOTE
<pre>默认情况下，如果是简单类型，则解析为@RequestParam。
或者：https://docs.spring.io/spring-framework/docs/5.2.5.BUILD-SNAPSHOT/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-</pre>

##### Return Values\(返回值\)
> collapsed=`true`

- NOTE
<pre>所有的返回值都支持响应式类型。</pre>

###### @ResponseBody
- NOTE
<pre>通过HttpMessageWriter编码返回值并写入到response里面去。</pre>

###### HttpEntity\<B\>, ResponseEntity\<B\>
- NOTE
<pre>返回值指定完整的响应，包括HTTP头部和正文；
然后经由HttpMessageWriter写入到HTTP response里面去。</pre>

###### HttpHeaders
- NOTE
<pre>返回一个有HTTP头部但是没有内容体的response。</pre>

###### String
- NOTE
<pre>返回成模板名称，会被视图解析器解析然后得到模板名。</pre>

###### View
- NOTE
<pre>返回一个视图。</pre>

###### java\.util\.Map, org\.springframework\.ui\.Model
- NOTE
<pre>基于请求路径，隐式地确定视图名称；
属性被隐式地添加到模型数据。</pre>

###### @ModelAttribute
- NOTE
<pre>准备添加到模型数据里面去；
视图名从请求路径里面隐式地推断。</pre>

###### Rendering
- NOTE
<pre>用于模型和视图渲染方案的API。</pre>

###### void
- NOTE
<pre>返回值为空的方法，可能是异步的；
如果参数有ServerHttpResponse，ServerWebExchange，或@ResponseStatus注解；
那么表明此方法完全处理了响应，不需要返回值然后让Spring写出。

还有一种可能就是，没有ResponseBody，只有ResponseHeader。</pre>

###### Flux\<ServerSentEvent\>, Observable\<ServerSentEvent\>, or other reactive type
- NOTE
<pre>发送服务器事件；
仅需要写入数据时，可以省略ServerSentEvent包装器。
若想使用&quot;text/event-stream&quot;;
必须通过produces属性在映射中请求或声明&quot;text/event-stream&quot;。</pre>

###### Any other return value
- LINK
<pre>https://docs.spring.io/spring-framework/docs/5.2.5.BUILD-SNAPSHOT/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-</pre>
- NOTE
<pre>https://docs.spring.io/spring-framework/docs/5.2.5.BUILD-SNAPSHOT/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-</pre>

##### Type Conversion
- NOTE
<pre>对于String形式的输入请求，如果声明的类型不是String；那么会发生强制类型转换。

除了基本类型的强制类型转换，还可以通过WebDataBinder；
或者通过FormattingConversionService注册Formatters来实现自定义转换。</pre>

##### Matrix Variables
- NOTE
<pre>矩阵变量，出现在URI中，其中每个变量之间用';'分隔；每个值之间用','分隔；
例如：&quot;/cars;color=red,green;year=2012&quot;;
其中有三个变量：[cars], [color], [year]; 其中[color]对应两个值: red, green。
多个值可以分开来对应一个变量；
比如: &quot;color=red;color=green;color=blue&quot;意味着color有三个值。

不同于Spring MVC，矩阵变量的缺省不影响请求映射；
如果你想访问矩阵变量，你可以在URI请求路径里面添加变量来接收矩阵变量，比如：
// GET /pets/42;q=11;r=22

@GetMapping(&quot;/pets/{petId}&quot;)
public void findPet(@PathVariable String petId, @MatrixVariable int q) {

    // petId == 42
    // q == 11
}

对于可能产生歧义的，可以指出唯一的变量：
// GET /owners/42;q=11/pets/21;q=22

@GetMapping(&quot;/owners/{ownerId}/pets/{petId}&quot;)
public void findPet(
        @MatrixVariable(name=&quot;q&quot;, pathVar=&quot;ownerId&quot;) int q1,
        @MatrixVariable(name=&quot;q&quot;, pathVar=&quot;petId&quot;) int q2) {

    // q1 == 11
    // q2 == 22
}

也可以对可选参数设置默认值：
// GET /pets/42

@GetMapping(&quot;/pets/{petId}&quot;)
public void findPet(@MatrixVariable(required=false, defaultValue=&quot;1&quot;) int q) {

    // q == 1
}

亦可以使用MultiValueMap来获取矩阵变量的所有值：
// GET /owners/42;q=11;r=12/pets/21;q=22;s=23

@GetMapping(&quot;/owners/{ownerId}/pets/{petId}&quot;)
public void findPet(
        @MatrixVariable MultiValueMap&lt;String, String&gt; matrixVars,
        @MatrixVariable(pathVar=&quot;petId&quot;) MultiValueMap&lt;String, String&gt; petMatrixVars) {

    // matrixVars: [&quot;q&quot; : [11,22], &quot;r&quot; : 12, &quot;s&quot; : 23]
    // petMatrixVars: [&quot;q&quot; : 22, &quot;s&quot; : 23]
}</pre>

##### @RequestParam
- NOTE
<pre>不同于Spring MVC，WebFlux的@RequestParam注解不会把查询参数，表单数据和文件/二进制数据绑定到一块；
WebFlux的@RequestParam默认只有查询参数，因此，若想实现绑定，可以使用数据绑定把
查询参数，表单数据，二进制/文件数据变成命令对象；

默认情况下使用@RequestParam注解的方法参数是必须要传递的，
但是您可以通过将@RequestParam的required标志设置为false或通过使用java.util.Optional包装器声明参数来指定方法参数是可选的。

当在Map &lt;String，String&gt;或MultiValueMap &lt;String，String&gt;参数上声明@RequestParam注解时，
将使用所有查询参数填充Map。

此注解是可选的，意思是：
任何没有被其他参数解析的基本类型都会被视为使用@RequestParam注解修饰的。</pre>

##### @RequestHeader
- NOTE
<pre>可以使用此注解把请求头绑定到方法参数上，比如：
Host                             localhost:8080
Accept                          text/html,application/xhtml+xml,application/xml;q=0.9
Accept-Language          fr,en-gb;q=0.7,en;q=0.3
Accept-Encoding           gzip,deflate
Accept-Charset             ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive                    300

@GetMapping(&quot;/demo&quot;)
public void handle(
        @RequestHeader(&quot;Accept-Encoding&quot;) String encoding, // 获取接受的编码类型
        @RequestHeader(&quot;Keep-Alive&quot;) long keepAlive) { // 获取是否保持连接
    //...
}

同样，要是使用Map或MultiValueMap来充当注解的参数，那么也会自动填充Map。</pre>

##### @CookieValue
- NOTE
<pre>可以使用@CookieValue注解将HTTP cookie的值绑定到控制器中的方法参数上来。</pre>

##### @ModelAttribute

##### @SessionAttributes

##### @SessionAttribute

##### @RequestAttribute

##### Multipart Content

##### @RequestBody

##### HttpEntity

##### @ResponseBody

##### ResponseEntity

##### Jackson JSON

###### JSON Views

#### Model\(模型数据\)

#### DataBinder\(数据绑定器\)

#### Managing Exceptions\(管理异常\)

##### REST API exceptions

#### Controller Advice\(控制器建议\)

### Functional Points\(功能性端点\)
> collapsed=`true`


#### HandlerFunction\(处理器函数\)
> collapsed=`true`


##### ServerRequest\(服务器请求\)

##### ServerResponse\(服务器响应\)

##### Handler Classes\(处理器类\)

##### Validation\(验证方式\)

#### HandlerFunction\(路由器功能\)
> collapsed=`true`


##### Predicates\(断言\)

##### Routes\(路由\)

##### Nested Routes\(嵌套路由\)

#### Running a Server\(运行一个服务器\)

#### Filtering Handler Functions\(过滤处理器函数\)

### URI Links\(URI链接\)
> collapsed=`true`


#### UriComponents\(URI组成部分\)

#### UriBuilder\(URI构建器\)

#### URI Encoding\(URI编码\)

### CORS\(跨域访问\)
> collapsed=`true`


#### Introduction\(导论\)

#### Processing\(处理\)

#### @CrossOrigin

#### Global Configuration\(全局配置\)

#### CORS WebFilter\(跨域访问过滤器\)

### Web Security\(Web安全\)

### View Technologies\(视图技术\)
> collapsed=`true`


#### Thymeleaf

#### FreeMarker
> collapsed=`true`


##### View Configuration

##### FreeMarker Configuration

##### Form Handling

#### Script Views

#### JSON and XML

### HTTP Caching\(HTTP缓存\)
> collapsed=`true`


#### CacheControl\(缓存控制\)

#### Controllers\(控制器\)

#### Static Resources\(静态资源\)

### WebFlux Config\(WebFlux配置\)
> collapsed=`true`


#### Enabling WebFlux Config\(启用WebFlux配置\)

#### WebFlux config API\(WebFlux配置API\)

#### Conversion, formatting\(转换和格式化\)

#### Validation\(验证方式\)

#### Content Type Resolvers\(内容类型解析器\)

#### HTTP message codecs\(HTTP消息编/解码器\)

#### View Resolvers\(视图解析器\)

#### Static Resources\(静态资源\)

#### Path Matching\(路径匹配\)

#### Advanced Configuration Mode\(高级配置模块\)

### HTTP/2

## WebClient
> collapsed=`true`


### Configuration\(配置\)
> collapsed=`true`


#### MaxInMemorySize\(最大内存大小\)

#### Reactor Netty\(Reactor模式下的Netty\)
> collapsed=`true`


##### Resources\(资源\)

##### Timeouts\(超市\)

#### Jetty

### retrieve\(\) \(回收\)

### exchange\(\) \(交换\)

### Request Body\(请求体\)
> collapsed=`true`


#### Form Data\(表单数据\)

#### Multipart Data\(文件/二进制数据\)

### Client Filters\(客户端过滤器\)

### Synchronous Use\(同步使用\)

### Testing\(测试\)

## WebSockets
> collapsed=`true`


### Introduction to WebSocket\(WebSocket导论\)
> collapsed=`true`


#### HTTP Versus WebSocket\(HTTP和WebSocket的比较\)

#### When to Use WebSockets\(什么时候使用WebSockets\)

### WebSocket API\(WebSocket接口\)
> collapsed=`true`


#### Server\(服务器\)

#### WebSocketHandler\(WebSocket处理器\)

#### DataBuffer\(数据缓冲组件\)

#### Handshake\(数据报握手\)

#### Server Configation\(服务器配置\)

#### CORS\(跨域访问\)

#### Client\(客户端\)
